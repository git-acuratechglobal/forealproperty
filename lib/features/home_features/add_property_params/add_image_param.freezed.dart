// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'add_image_param.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

AddImage _$AddImageFromJson(Map<String, dynamic> json) {
  return _AddImage.fromJson(json);
}

/// @nodoc
mixin _$AddImage {
  @JsonKey(name: "PropertyBuildingTypeZoning")
  String get propertyBuildingTypeZoning => throw _privateConstructorUsedError;
  @JsonKey(name: "PropertyDescription")
  String? get propertyDescription => throw _privateConstructorUsedError;
  @JsonKey(name: "PropertyHeading")
  String? get propertyHeading => throw _privateConstructorUsedError;
  @JsonKey(name: "PropertyId")
  int? get propertyId => throw _privateConstructorUsedError;
  @JsonKey(name: "PropertyImages")
  List<String>? get propertyImages => throw _privateConstructorUsedError;
  @JsonKey(name: "PropertyLandAreaL")
  String get propertyLandAreaL =>
      throw _privateConstructorUsedError; // because it's a string in JSON
  @JsonKey(name: "PropertyLandAreaW")
  int get propertyLandAreaW => throw _privateConstructorUsedError;
  @JsonKey(name: "FloorImages")
  List<String>? get floorImages => throw _privateConstructorUsedError;

  /// Serializes this AddImage to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of AddImage
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $AddImageCopyWith<AddImage> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AddImageCopyWith<$Res> {
  factory $AddImageCopyWith(AddImage value, $Res Function(AddImage) then) =
      _$AddImageCopyWithImpl<$Res, AddImage>;
  @useResult
  $Res call(
      {@JsonKey(name: "PropertyBuildingTypeZoning")
      String propertyBuildingTypeZoning,
      @JsonKey(name: "PropertyDescription") String? propertyDescription,
      @JsonKey(name: "PropertyHeading") String? propertyHeading,
      @JsonKey(name: "PropertyId") int? propertyId,
      @JsonKey(name: "PropertyImages") List<String>? propertyImages,
      @JsonKey(name: "PropertyLandAreaL") String propertyLandAreaL,
      @JsonKey(name: "PropertyLandAreaW") int propertyLandAreaW,
      @JsonKey(name: "FloorImages") List<String>? floorImages});
}

/// @nodoc
class _$AddImageCopyWithImpl<$Res, $Val extends AddImage>
    implements $AddImageCopyWith<$Res> {
  _$AddImageCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of AddImage
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? propertyBuildingTypeZoning = null,
    Object? propertyDescription = freezed,
    Object? propertyHeading = freezed,
    Object? propertyId = freezed,
    Object? propertyImages = freezed,
    Object? propertyLandAreaL = null,
    Object? propertyLandAreaW = null,
    Object? floorImages = freezed,
  }) {
    return _then(_value.copyWith(
      propertyBuildingTypeZoning: null == propertyBuildingTypeZoning
          ? _value.propertyBuildingTypeZoning
          : propertyBuildingTypeZoning // ignore: cast_nullable_to_non_nullable
              as String,
      propertyDescription: freezed == propertyDescription
          ? _value.propertyDescription
          : propertyDescription // ignore: cast_nullable_to_non_nullable
              as String?,
      propertyHeading: freezed == propertyHeading
          ? _value.propertyHeading
          : propertyHeading // ignore: cast_nullable_to_non_nullable
              as String?,
      propertyId: freezed == propertyId
          ? _value.propertyId
          : propertyId // ignore: cast_nullable_to_non_nullable
              as int?,
      propertyImages: freezed == propertyImages
          ? _value.propertyImages
          : propertyImages // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      propertyLandAreaL: null == propertyLandAreaL
          ? _value.propertyLandAreaL
          : propertyLandAreaL // ignore: cast_nullable_to_non_nullable
              as String,
      propertyLandAreaW: null == propertyLandAreaW
          ? _value.propertyLandAreaW
          : propertyLandAreaW // ignore: cast_nullable_to_non_nullable
              as int,
      floorImages: freezed == floorImages
          ? _value.floorImages
          : floorImages // ignore: cast_nullable_to_non_nullable
              as List<String>?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$AddImageImplCopyWith<$Res>
    implements $AddImageCopyWith<$Res> {
  factory _$$AddImageImplCopyWith(
          _$AddImageImpl value, $Res Function(_$AddImageImpl) then) =
      __$$AddImageImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: "PropertyBuildingTypeZoning")
      String propertyBuildingTypeZoning,
      @JsonKey(name: "PropertyDescription") String? propertyDescription,
      @JsonKey(name: "PropertyHeading") String? propertyHeading,
      @JsonKey(name: "PropertyId") int? propertyId,
      @JsonKey(name: "PropertyImages") List<String>? propertyImages,
      @JsonKey(name: "PropertyLandAreaL") String propertyLandAreaL,
      @JsonKey(name: "PropertyLandAreaW") int propertyLandAreaW,
      @JsonKey(name: "FloorImages") List<String>? floorImages});
}

/// @nodoc
class __$$AddImageImplCopyWithImpl<$Res>
    extends _$AddImageCopyWithImpl<$Res, _$AddImageImpl>
    implements _$$AddImageImplCopyWith<$Res> {
  __$$AddImageImplCopyWithImpl(
      _$AddImageImpl _value, $Res Function(_$AddImageImpl) _then)
      : super(_value, _then);

  /// Create a copy of AddImage
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? propertyBuildingTypeZoning = null,
    Object? propertyDescription = freezed,
    Object? propertyHeading = freezed,
    Object? propertyId = freezed,
    Object? propertyImages = freezed,
    Object? propertyLandAreaL = null,
    Object? propertyLandAreaW = null,
    Object? floorImages = freezed,
  }) {
    return _then(_$AddImageImpl(
      propertyBuildingTypeZoning: null == propertyBuildingTypeZoning
          ? _value.propertyBuildingTypeZoning
          : propertyBuildingTypeZoning // ignore: cast_nullable_to_non_nullable
              as String,
      propertyDescription: freezed == propertyDescription
          ? _value.propertyDescription
          : propertyDescription // ignore: cast_nullable_to_non_nullable
              as String?,
      propertyHeading: freezed == propertyHeading
          ? _value.propertyHeading
          : propertyHeading // ignore: cast_nullable_to_non_nullable
              as String?,
      propertyId: freezed == propertyId
          ? _value.propertyId
          : propertyId // ignore: cast_nullable_to_non_nullable
              as int?,
      propertyImages: freezed == propertyImages
          ? _value._propertyImages
          : propertyImages // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      propertyLandAreaL: null == propertyLandAreaL
          ? _value.propertyLandAreaL
          : propertyLandAreaL // ignore: cast_nullable_to_non_nullable
              as String,
      propertyLandAreaW: null == propertyLandAreaW
          ? _value.propertyLandAreaW
          : propertyLandAreaW // ignore: cast_nullable_to_non_nullable
              as int,
      floorImages: freezed == floorImages
          ? _value._floorImages
          : floorImages // ignore: cast_nullable_to_non_nullable
              as List<String>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$AddImageImpl implements _AddImage {
  const _$AddImageImpl(
      {@JsonKey(name: "PropertyBuildingTypeZoning")
      this.propertyBuildingTypeZoning = "A2",
      @JsonKey(name: "PropertyDescription") this.propertyDescription,
      @JsonKey(name: "PropertyHeading") this.propertyHeading,
      @JsonKey(name: "PropertyId") this.propertyId,
      @JsonKey(name: "PropertyImages") final List<String>? propertyImages,
      @JsonKey(name: "PropertyLandAreaL") this.propertyLandAreaL = "400",
      @JsonKey(name: "PropertyLandAreaW") this.propertyLandAreaW = 8,
      @JsonKey(name: "FloorImages") final List<String>? floorImages})
      : _propertyImages = propertyImages,
        _floorImages = floorImages;

  factory _$AddImageImpl.fromJson(Map<String, dynamic> json) =>
      _$$AddImageImplFromJson(json);

  @override
  @JsonKey(name: "PropertyBuildingTypeZoning")
  final String propertyBuildingTypeZoning;
  @override
  @JsonKey(name: "PropertyDescription")
  final String? propertyDescription;
  @override
  @JsonKey(name: "PropertyHeading")
  final String? propertyHeading;
  @override
  @JsonKey(name: "PropertyId")
  final int? propertyId;
  final List<String>? _propertyImages;
  @override
  @JsonKey(name: "PropertyImages")
  List<String>? get propertyImages {
    final value = _propertyImages;
    if (value == null) return null;
    if (_propertyImages is EqualUnmodifiableListView) return _propertyImages;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  @JsonKey(name: "PropertyLandAreaL")
  final String propertyLandAreaL;
// because it's a string in JSON
  @override
  @JsonKey(name: "PropertyLandAreaW")
  final int propertyLandAreaW;
  final List<String>? _floorImages;
  @override
  @JsonKey(name: "FloorImages")
  List<String>? get floorImages {
    final value = _floorImages;
    if (value == null) return null;
    if (_floorImages is EqualUnmodifiableListView) return _floorImages;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'AddImage(propertyBuildingTypeZoning: $propertyBuildingTypeZoning, propertyDescription: $propertyDescription, propertyHeading: $propertyHeading, propertyId: $propertyId, propertyImages: $propertyImages, propertyLandAreaL: $propertyLandAreaL, propertyLandAreaW: $propertyLandAreaW, floorImages: $floorImages)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AddImageImpl &&
            (identical(other.propertyBuildingTypeZoning,
                    propertyBuildingTypeZoning) ||
                other.propertyBuildingTypeZoning ==
                    propertyBuildingTypeZoning) &&
            (identical(other.propertyDescription, propertyDescription) ||
                other.propertyDescription == propertyDescription) &&
            (identical(other.propertyHeading, propertyHeading) ||
                other.propertyHeading == propertyHeading) &&
            (identical(other.propertyId, propertyId) ||
                other.propertyId == propertyId) &&
            const DeepCollectionEquality()
                .equals(other._propertyImages, _propertyImages) &&
            (identical(other.propertyLandAreaL, propertyLandAreaL) ||
                other.propertyLandAreaL == propertyLandAreaL) &&
            (identical(other.propertyLandAreaW, propertyLandAreaW) ||
                other.propertyLandAreaW == propertyLandAreaW) &&
            const DeepCollectionEquality()
                .equals(other._floorImages, _floorImages));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      propertyBuildingTypeZoning,
      propertyDescription,
      propertyHeading,
      propertyId,
      const DeepCollectionEquality().hash(_propertyImages),
      propertyLandAreaL,
      propertyLandAreaW,
      const DeepCollectionEquality().hash(_floorImages));

  /// Create a copy of AddImage
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$AddImageImplCopyWith<_$AddImageImpl> get copyWith =>
      __$$AddImageImplCopyWithImpl<_$AddImageImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$AddImageImplToJson(
      this,
    );
  }
}

abstract class _AddImage implements AddImage {
  const factory _AddImage(
      {@JsonKey(name: "PropertyBuildingTypeZoning")
      final String propertyBuildingTypeZoning,
      @JsonKey(name: "PropertyDescription") final String? propertyDescription,
      @JsonKey(name: "PropertyHeading") final String? propertyHeading,
      @JsonKey(name: "PropertyId") final int? propertyId,
      @JsonKey(name: "PropertyImages") final List<String>? propertyImages,
      @JsonKey(name: "PropertyLandAreaL") final String propertyLandAreaL,
      @JsonKey(name: "PropertyLandAreaW") final int propertyLandAreaW,
      @JsonKey(name: "FloorImages")
      final List<String>? floorImages}) = _$AddImageImpl;

  factory _AddImage.fromJson(Map<String, dynamic> json) =
      _$AddImageImpl.fromJson;

  @override
  @JsonKey(name: "PropertyBuildingTypeZoning")
  String get propertyBuildingTypeZoning;
  @override
  @JsonKey(name: "PropertyDescription")
  String? get propertyDescription;
  @override
  @JsonKey(name: "PropertyHeading")
  String? get propertyHeading;
  @override
  @JsonKey(name: "PropertyId")
  int? get propertyId;
  @override
  @JsonKey(name: "PropertyImages")
  List<String>? get propertyImages;
  @override
  @JsonKey(name: "PropertyLandAreaL")
  String get propertyLandAreaL; // because it's a string in JSON
  @override
  @JsonKey(name: "PropertyLandAreaW")
  int get propertyLandAreaW;
  @override
  @JsonKey(name: "FloorImages")
  List<String>? get floorImages;

  /// Create a copy of AddImage
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$AddImageImplCopyWith<_$AddImageImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
